# Multithreaded Tank Battle Simulator - TAU, Assignment 3 - Semester B , 2025
Project submitted by:
Yael Sagi, 206480972
Noga Arian, 206899163

📖 Overview

This project extends previous assignments (Ex1 & Ex2) into a multithreaded simulator that can run multiple tank battle games concurrently.

Assignment 1: Implemented the base game mechanics (board, tanks, shells, mines, etc.).

Assignment 2: Added a GameManager with deterministic rules, detailed logging, and structured output files.

Assignment 3 (this project): Introduces a Simulator that loads external GameManager and Algorithm implementations dynamically (.so shared libraries), and supports two modes of execution:

Comparative mode – compare multiple GameManagers on the same game map and algorithms.

Competition mode – run a tournament of multiple algorithms across multiple game maps.

## Approved Implementation Choices

1. We implemented a `Player` class and corresponding `Algorithm`, an advanced strategy adapted for ass
2. We extended our static multiton Logger design to ensure synchronized logging across all GameManager instances and Simulator threads.
3. All Managers and Algorithms are compiled to `.so` files and loaded via a registrar mechanism. Validation is performed on load.
4. Multithreading is used to improve runtime performance in both modes.
5. In addition to local Makefiles for each module, we provide a top-level Makefile to streamline building the entire project from root.
6. We implemented GetBattleInfo so it would cancel backward movements.
7. All other action requests are ignored during this waiting period, and the backward movement proceeds as planned.

📂 Project Structure

The submission is organized into 5 folders and one root-level Makefile:

ex3_206480972_206899163/
│── Simulator/       # Simulator implementation (executable target)
│── GameManager/     # GameManager implementation (.so target)
│── Algorithm/       # Algorithms + Player implementations (.so target)
│── common/          # Provided headers from course staff (NO CHANGES)
│── UserCommon/      # Shared utilities (namespaced to our IDs)
│── Makefile         # Root Makefile (build all subprojects)
│── students.txt     # List of submitters
│── bonus.txt        # Bounus request included features
│── README.md        # This file

## Input File Format
### 1. **Game Settings (First 5 Lines)**

```
<MapName>
MaxSteps = <NUM>
NumShells = <NUM>
Rows = <NUM>
Cols = <NUM>
```
### 2. **Map Layout**
Each following line describes a row of the board.
- `#`: Wall
- `@`: Mine
- `1`–`2`: Tank belonging to Player 1 or Player2
- Space (` `): Empty cell
- Any other character: Treated as Empty cell

## Output Files

### GameManager Verbose Output

If `-verbose` is enabled, each GameManager creates a file `output_game_map_<player1>_vs_<player2>_<time>.txt` in the same format as in assignment 2 and also
adds detailed_output as a bonus.
Each line contains actions taken by each tank in the order they appear (top-to-bottom, left-to-right).

* Ignored actions: `(ignored)`
* Killed tanks: `killed`
* Action + killed: `SomeAction (ignored) (killed)`

#### Last Line Format
```
Player <X> won with <Y> tanks still alive
Tie, both players have zero tanks
Tie, reached max steps = <MAX_STEPS>, player 1 has <X> tanks, player 2 has <Y> tanks
Tie, both players have zero shells for <zero_shells_steps> steps
```
### input_errors.txt

Generated by the GameManager while parsing the input.

## Game Rules:

**Available Actions**: MoveForward, MoveBackward, RotateRight45, RotateRight90, RotateLeft45, RotateLeft90, Shoot, DoNothing, GetBattleInfo.
**Shell Mechanics**: Move <shells_speed> cells per turn, destroy tanks, weaken walls.
* **Ammunition Limit**: Each tank begins with <NumShells> shells (There is no reloading).
* **Board Wrapping** The board is looped, meaning moving off one edge brings the unit back on the opposite side.
* **Victory Condition:**: A player wins by eliminating all enemy tanks.troy opponent’s tank.

## Victory and Draw Conditions

**Total Elimination**  – A player wins instantly when the opponent has no tanks left on the field* **Mutual Destruction** – If the last tanks of both players are destroyed within the same step, the result is a tie.
* **Shell Depletion Stalemate** – If every remaining tank runs out of shells, the game continues for <zero_shells_steps>. If no tank is destroyed during this period, the match ends in a tie.
* **Maximum Step Limit** – If the game reaches <MaxSteps> without a winner, it is declared a tie.
* **Evaluation Timing** – All win/tie conditions are evaluated at the beginning of the step.
  For instance, if Player 1’s last tank is destroyed in the first half-turn and Player 2’s in the second, both events are considered together at the beginning of the next step, the game is declared as a **tie**.

🛠 Compilation

Each folder has its own Makefile.
From the project root, compile everything:m

make

Builds the Simulator executable: make sim

Builds the Algorithm shared library: make algo

Builds the GameManager shared library: make gm

To clean all build artifacts:

make clean

🚀 Running the Simulator

The Simulator supports two modes:

1. Comparative Mode:
   ./Simulator/simulator -comparative \
   game_map=<map_file> \
   game_managers_folder=<gm_folder> \
   algorithm1=<algo1.so> \
   algorithm2=<algo2.so> \
   [num_threads=<num>] \
   [-verbose]

Runs all GameManagers in the folder on the same map, with two chosen algorithms.
Grouped results are written to the output file.

Output written to:
comparative_results_<time>.txt (under game_managers_folder).

2. Competition Mode
   ./Simulator/simulator -competition \
   game_maps_folder=<maps_folder> \
   game_manager=<gm.so> \
   algorithms_folder=<algos_folder> \
   [num_threads=<num>] \
   [-verbose]

Runs a tournament where all algorithms in the folder compete across all maps.

Pairing logic ensures each algorithm competes against multiple opponents per map.

Output written to:
competition_<time>.txt (under algorithms_folder).

Example structure:

game_map=simple.map
algorithm1=Algorithm_206480972_206899163.so
algorithm2=Algorithm_206480972_206899163.so

<GameManager(s) achieving identical results>
<Player X won with Y tanks still alive / Tie condition>
<round_number>
<final board state>


Example structure:

game_maps_folder=maps/
game_manager=GameManager_206480972.so

Algorithm_A 9
Algorithm_B 7
Algorithm_C 3
...

Scoring:

Win: 3 points

Tie: 1 point per participant

Loss: 0 points

🧵 Multithreading Model

num_threads=1 or missing → run on main thread only.

num_threads ≥ 2 → use <num_threads> worker threads in addition to main thread.

Total threads will never be exactly 2 (main + ≥2 workers).

Simulator uses std::thread and a thread-safe queue to dispatch games.

Synchronization is minimized (locks only when required).


📝 Error Handling

Missing/invalid command-line arguments → print usage + error message.

Nonexistent map/algorithm/game manager file or empty folder → usage + error message.

If results file cannot be created, print results to stdout instead.

Simulator must not crash except if external GameManager/Algorithm crashes internally.
